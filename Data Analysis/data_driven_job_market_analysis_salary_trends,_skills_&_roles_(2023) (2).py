# -*- coding: utf-8 -*-
"""Data-Driven Job Market Analysis: Salary Trends, Skills & Roles (2023).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iYqr1oFBsC2tS7gOVjW1xII6647RpZXq
"""

"""
Data-Driven Job Market Analysis Script
--------------------------------------
This script analyzes job market trends, including salary distributions,
job titles, experience levels, and remote work preferences. It uses
the ds_salaries.csv dataset for analysis.

Author: BRAJESH YADAV


Libraries Used:
- pandas
- numpy
- matplotlib
"""

import pandas as pd
import numpy as np
import re


df=pd.read_csv("ds_salaries.csv")

df.isnull().sum()
df["salary"]=pd.to_numeric(df["salary"])
df
df.isnull().sum()
df["salary_in_usd"]=pd.to_numeric(df["salary_in_usd"])
df.isnull().sum()
#print(df.head())
print("\n")
category_job_title=df["job_title"].unique()
category_data_scientist=df[df["job_title"].str.contains(r"\bdata\s+scientist\b",regex=True,case=False)==True]["job_title"].unique()
print(category_data_scientist)
df['job_title'].replace({
'Principal Data Scientist':'Data Scientist',
'Applied Data Scientist':'Data Scientist',
'Lead Data Scientist':'Data Scientist',
'Data Scientist Lead':'Data Scientist',
'Product Data Scientist':'Data Scientist',
'Staff Data Scientist':'Data Scientist'},inplace=True)
#print("\n")
#print(category_job_title)

def unique_preserve_order(lst):
    seen = set()
    unique = []
    for item in lst:
        if item not in seen:
            unique.append(item)
            seen.add(item)
    return unique

# # Example
# lst = ['apple', 'banana', 'apple', 'orange']
# print(unique_preserve_order(lst))
# # Output: ['apple', 'banana', 'orange']
print("\n")
list_unique_job_title=unique_preserve_order(category_job_title)
# print(len(list_unique_job_title))
# print("\n")
df
# data_scientist_job_title
data_scientist_category=[]
for item in list_unique_job_title:
  if re.search(r"\bdata\s+scientist\b",item,flags=re.IGNORECASE):
    data_scientist_category.append(item)


# print(data_scientist_category)


# data_analyst_job_title
data_analyst_category=[]
print("\n")
for item in list_unique_job_title:
  if re.search(r"\bdata\s+analyst\b",item,flags=re.IGNORECASE):
      data_analyst_category.append(item)

# print(data_analyst_category)
# data_engineer_job_title
data_engineer_category=[]
print("\n")
for item in list_unique_job_title:
  if re.search(r"\bdata\s+engineer\b",item,flags=re.IGNORECASE):
    data_engineer_category.append(item)

# print(data_engineer_category)
# print(len(data_scientist_category)+ len(data_analyst_category)+len(data_engineer_category))

combined_data_scientist_analyst_engineer=data_scientist_category+data_analyst_category+data_engineer_category
combined_data_scientist_analyst_engineer
len(combined_data_scientist_analyst_engineer)

remaining_job_title=[]
for item in list_unique_job_title:
  if item not in combined_data_scientist_analyst_engineer:
    remaining_job_title.append(item)
# print("\n")
# print(remaining_job_title)
# print("\n")
# len(remaining_job_title)+len(combined_data_scientist_analyst_engineer)


#replacement
data_analyst_replacement={title:"Data Analyst" for title in data_analyst_category}
df["job_title"]=df["job_title"].replace(data_analyst_replacement)

data_engineer_replacement={title:"Data Engineer" for title in data_engineer_category}
df["job_title"]=df["job_title"].replace(data_engineer_replacement)

df["job_title"].unique()


#find different types of job_titles
# print(df["job_title"].value_counts())
# print(df["job_title"].value_counts().values)
single_frequency_title=[]
multi_frequency_title=[]
for index,values in df["job_title"].value_counts().items() :
  if values > 1:
      multi_frequency_title.append(index)
  else:
      single_frequency_title.append(index)

print(f"single_frequency_title:{single_frequency_title}")
print('\n')
print('\n')
print('\n')
print('\n')
print(f"multi_frequency_title:{multi_frequency_title}")

#normalization of job title except data engineer, analyst and scientist
normalizations = {
  'Power BI Developer': 'BI Developer',
  'Principal Machine Learning Engineer': 'Lead Machine Learning Engineer',
  'Deep Learning Researcher': 'Machine Learning Researcher',
  'Data Science Tech Lead': 'Data Science Lead',
  'Principal Data Architect': 'Data Architect',
  'Head of Machine Learning': 'Machine Learning Manager',
  'Data Management Specialist': 'Data Specialist',
  'Manager Data Management': 'Data Manager'
}
df["job_title"]=df["job_title"].replace(normalizations)
df["job_title"]

print(df["experience_level"].unique())

"""
SE - Senior Level
MI - Mid-Level
EN - Entry Level (Junior)
EX - Executive Level

"""
#checking the size of executive level experience
total_rows=df.shape[0]
rows_executive_level_experience=df[df["experience_level"]=="EX"].shape[0]
rows_executive_level_experience
proportion_ececutive_level_experience=(rows_executive_level_experience*1.0/total_rows)*100
proportion_ececutive_level_experience

"""
Since the proportion of executive level experinence is 3.036%,
I am treating it as the senior level experience.
"""
#replacing ex with se
# Replace EX with SE in the entire column
df_original=pd.read_csv("ds_salaries.csv")
df["experience_level"]=df_original["experience_level"]
df["experience_level_updated"] = df["experience_level"].replace({'EX': 'SE'})
print(df["experience_level_updated"].unique())


df.head()
#normalizing company_locations
df["company_location"].unique()
continent_mapping = {
    # North America
    'US': 'North America',
    'CA': 'North America',
    'MX': 'North America',
    'CR': 'North America',
    'HN': 'North America',
    'BS': 'North America',
    'PR': 'North America',

    # South America
    'CO': 'South America',
    'BR': 'South America',
    'AR': 'South America',
    'CL': 'South America',
    'BO': 'South America',
    'ES': 'Europe',  # Spain - assuming this is correct

    # Europe
    'DE': 'Europe',
    'GB': 'Europe',
    'NL': 'Europe',
    'CH': 'Europe',
    'FR': 'Europe',
    'FI': 'Europe',
    'UA': 'Europe',
    'IE': 'Europe',
    'SE': 'Europe',
    'SI': 'Europe',
    'PT': 'Europe',
    'RU': 'Europe',
    'HR': 'Europe',
    'EE': 'Europe',
    'AM': 'Europe',
    'BA': 'Europe',
    'GR': 'Europe',
    'MK': 'Europe',
    'LV': 'Europe',
    'RO': 'Europe',
    'IT': 'Europe',
    'PL': 'Europe',
    'AL': 'Europe',
    'LT': 'Europe',
    'HU': 'Europe',
    'AT': 'Europe',
    'SK': 'Europe',
    'CZ': 'Europe',
    'TR': 'Europe',
    'DK': 'Europe',
    'BE': 'Europe',
    'LU': 'Europe',
    'MT': 'Europe',
    'MD': 'Europe',

    # Asia
    'IN': 'Asia',
    'HK': 'Asia',
    'IL': 'Asia',
    'SG': 'Asia',
    'TH': 'Asia',
    'VN': 'Asia',
    'PK': 'Asia',
    'IR': 'Asia',
    'PH': 'Asia',
    'ID': 'Asia',
    'MY': 'Asia',
    'JP': 'Asia',
    'CN': 'Asia',
    'IQ': 'Asia',

    # Africa
    'NG': 'Africa',
    'CF': 'Africa',
    'GH': 'Africa',
    'KE': 'Africa',
    'MA': 'Africa',
    'EG': 'Africa',
    'DZ': 'Africa',

    # Oceania
    'AU': 'Oceania',
    'NZ': 'Oceania',
    'AS': 'Oceania',

    # Middle East (can be grouped with Asia if preferred)
    'AE': 'Middle East'
}

df['continent']=df["company_location"].replace(continent_mapping)
df.head()


#Analyze average salary by role,region,experience

#By role
#1.Data Engineer
df_data_engineers=df[df["job_title"]=="Data Engineer"]

average_data_engineers_salary=df_data_engineers["salary_in_usd"].mean()
print(f"\n The average salary of data engineers is {average_data_engineers_salary}.")

#2.Data Scientist
df_data_scientists=df[df["job_title"]=="Data Scientist"]

average_data_scientists_salary=df_data_scientists["salary_in_usd"].mean()
print(f"\n The average salary of data scientists is {average_data_scientists_salary}.")

#3.Data Analyst
df_data_analysts=df[df["job_title"]=="Data Analyst"]

average_data_analysts_salary=df_data_analysts["salary_in_usd"].mean()
print(f"\n The average salary of data scientists is {average_data_analysts_salary}.")
print("\n")
print(df["job_title"].unique())

#4.ML Engineer
df_ML_Engineer=df[df["job_title"]=="ML Engineer"]

average_ML_Engineer_salary=df_ML_Engineer["salary_in_usd"].mean()
print(f"\n The average salary of data scientists is {average_ML_Engineer_salary}.")

#5.Applied Scientist
df_Applied_Scientist=df[df["job_title"]=="Applied Scientist"]

average_Applied_Scientist_salary=df_Applied_Scientist["salary_in_usd"].mean()
print(f"\n The average salary of data scientists is {average_Applied_Scientist_salary}.")

#5.Applied Scientist
df_Applied_Scientist=df[df["job_title"]=="Applied Scientist"]

average_Applied_Scientist_salary=df_Applied_Scientist["salary_in_usd"].mean()
print(f"\n The average salary of data scientists is {average_Applied_Scientist_salary}.")

# Grouping to get the job with highest mean
group_by_job_titles=df.groupby("job_title")
#Top 10 job with highest salary
print("\n")
top_paying_jobs=group_by_job_titles["salary_in_usd"].mean().sort_values(ascending=False).head(10).rename_axis("TOP 10 Salaried Jobs").rename("average_salary_in_usd").reset_index()
print(top_paying_jobs)
"""************"""
#By region (continent)
group_by_job_titles_continent=df.groupby(['continent',"job_title"])
print(group_by_job_titles_continent['salary_in_usd'].mean())
print("\n")
print(group_by_job_titles_continent['salary_in_usd'].mean().groupby(level=0).idxmax().rename("Top Earner").reset_index())

#BY Experience
# when experience level are : ['SE' 'MI' 'EN' 'EX']
group_by_experience_level=df.groupby(["experience_level","job_title"])
print("\n")
salary_by_experience_level=group_by_experience_level["salary_in_usd"].mean().groupby(level=0).idxmax().rename("Top_Earners_by_Experience").reset_index()
print(salary_by_experience_level)
# when experience level are : ['SE' 'MI' 'EN' ]
group_by_experience_level_updated=df.groupby(["experience_level_updated","job_title"])
print("\n")
print(group_by_experience_level_updated["salary_in_usd"].mean().groupby(level=0).idxmax().rename("Top_Earners_by_Experience").reset_index())
#df.head()

#"Do remote workers earn more or less than office workers?" array([100,   0,  50])
#df['remote_ratio'].unique()

df_of_remote_workers=df[df["remote_ratio"]==100]
df_of_office_workers=df[df["remote_ratio"]==0]
df_of_hybrid_workers=df[df["remote_ratio"]==50]
print(df_of_hybrid_workers.shape[0])
print(df_of_office_workers.shape[0])
print(df_of_remote_workers.shape[0])
#salary of remote workers
print(df_of_remote_workers.groupby("job_title")["salary_in_usd"].mean().sort_values(ascending=False).head(10).rename("Top_Earners_in_Remote_Jobs").reset_index())

#salary of office workers
print("\n")
print(df_of_office_workers.groupby("job_title")["salary_in_usd"].mean().sort_values(ascending=False).head(10).rename("Top_Earners_in_Inoffice_Jobs").reset_index())

#salary fo hybrid workers
print("\n")
print(df_of_hybrid_workers.groupby("job_title")["salary_in_usd"].mean().sort_values(ascending=False).head(10).rename("Top_Earners_in_Hybrid_Jobs").reset_index())

#Top 10 job titles by demand: This means jobs with highest number of rows in descending order.
print("\n")
print(group_by_job_titles.size().sort_values(ascending=False).head(10).rename_axis("Top_10_Indemand_Jobs").reset_index()[["Top_10_Indemand_Jobs"]])

df.head()

#visualization

import matplotlib.pyplot as plt
import numpy as np

plt.figure()  # Create a new figure
fig, ax1 = plt.subplots(1, 1)  # Create a single subplot (figure and axes)

# Extract data for the barplot
categories = top_paying_jobs["TOP 10 Salaried Jobs"].tolist()  # X-axis
values = top_paying_jobs["average_salary_in_usd"].tolist()     # Y-axis

# Create the barplot
ax1.bar(categories, values, color='skyblue')

# Add labels and title
ax1.set_title('Top 10 Salaried Jobs')
ax1.set_xlabel('Job Titles')
ax1.set_ylabel('Average Salary (USD)')

# Rotate x-axis labels for better visibility
ax1.set_xticklabels(categories, rotation=45, ha='right')

# Show the plot
plt.tight_layout()
plt.show()

#salary distribution by experience level
#plt.figure()
#fig,ax2=plt.subplots(1,1)
print(group_by_experience_level["salary_in_usd"].mean().groupby(level=0).idxmax().rename("Top_Earners_by_Experience").reset_index())
experience_level=salary_by_experience_level["experience_level"].tolist()
top_earners=salary_by_experience_level["Top_Earners_by_Experience"].tolist()

